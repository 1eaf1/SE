# Тема 8. Основы объектно-ориентированного программирования
Отчет по Теме #8 выполнил(а):
- Фалалеев Евгений Алексеевич
- АИС-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | - |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями

```python
class Car: # Создание класса
    def __init__(self,maker,model): #Инициализация объектов класса в конструкторе
        self.maker = maker #Присвоение параметра maker атрибуту maker объекта класса Car
        self.model = model #Присвоение параметра model атрибуту model объекта класса Car

my_car = Car("Mazda","CX-5") #Создание объекта my_car класса Car и передача ему аргументов, которые станут атрибутами объекта
```

### Результат
![Меню](https://github.com/1eaf1/SE/blob/Тема_8/pic/Лаб1.png)

## Выводы
В данном коде создаётся класс Car и конструктор к данному классу с свойствами maker,model. После создания класса происходит создание объекта данного класса.

## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: # Создание класса
    def __init__(self,maker,model): #Инициализация объектов класса в конструкторе
        self.maker = maker #Присвоение параметра maker атрибуту maker объекта класса Car
        self.model = model #Присвоение параметра model атрибуту model объекта класса Car

    def drive(self): #функция созданная в классе Car, заставляющая машину "поехать"
        print(f"Driving the {self.maker} {self.model}") # Вывод информации об свойствах объекта

my_car = Car("Mazda","CX-5") #Создание объекта my_car класса Car и передача ему аргументов, которые станут атрибутами объекта
my_car.drive() # Вызов метода drive для объекта my_car
```

### Результат
![Лаб2](https://github.com/1eaf1/SE/blob/Тема_8/pic/Лаб2.png)

## Выводы
В данном коде создаётся класс Car, создаётся конструктор класса со свойствами объектов. Также создаётся функция drive() класса Car, которая выводит информацию в консоль о едущей машине - модели (self.model) и производителе(self.maker) объекта. За пределами класса осуществляется создание объекта данного класса и вызов функции drive().

## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: # Создание класса
    def __init__(self,maker,model): #Инициализация объектов класса в конструкторе
        self.maker = maker #Присвоение параметра maker атрибуту maker объекта класса Car
        self.model = model #Присвоение параметра model атрибуту model объекта класса Car

    def drive(self): #функция созданная в классе Car, заставляющая машину "поехать"
        print(f"Driving the {self.maker} {self.model}") # Вывод информации об свойствах объекта и о том, что машина едет

class ElectricCar(Car): # Создание класса ElectricCar, наследуемого от класса Car
    def __init__(self,maker,model,battery_capacity): # Конструктор класса ElectricCar
        super().__init__(maker,model) #Вызов метода __init__ родительского класса
        self.battery_capacity=battery_capacity #Присвоение параметра battery_capacity атрибуту battery_capacity объекта класса ElectricCar

    def charge(self): #Создание функции зарядки машины в классе ElectricCar
        print(f"Charging the {self.maker} {self.model} with {self.battery_capacity} kWh") #Вывод результата зарядки и свойств объекта

my_electric_car = ElectricCar("Tesla","Model S", 75) #Создание объекта my_car класса Car и передача ему аргументов, которые станут атрибутами объекта
my_electric_car.drive() # Вызов метода drive для объекта my_electric_car
my_electric_car.charge() # Вызов метода charge для объекта my_electric_car
```

### Результат
![Лаб3](https://github.com/1eaf1/SE/blob/Тема_8/pic/Лаб3.png)

## Выводы
В данном задании создаётся новый класс ElectricCar путём наследования свойств и методов от класса Car. Car - родительский класс дочернего класса ElectricCar. В ElectricCar создаётся функция зарядки автомобиля. За пределеами классов создаётся объект my_electric_car класса ElectricCar вызывающий методы drive() и charge() своего класса.
  
## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: # Создание класса
    def __init__(self,maker,model): #Инициализация объектов класса в конструкторе
        self._maker = maker #Защищённый атрибут
        self.__model = model #Приватный атрибут



    def drive(self): #функция созданная в классе Car, заставляющая машину "поехать"
        print(f"Driving the {self._maker} {self.__model}") # Вывод информации об свойствах объекта и о том, что машина едет


my_car = Car("Mazda","CX-5") #Создание объекта my_car класса Car
print(my_car._maker) # Вывод защищённого атрибута _maker
my_car.drive() #Запуск метода drive() объекта my_car
```

### Результат
![Лаб4](https://github.com/1eaf1/SE/blob/Тема_8/pic/Лаб4.png)

## Выводы
В данном классе Car осуществляется создание защищённого и приватного атрибутов в конструкторе класса, т.е. инкапсуляция свойств объекта. За пределами класса осуществляется вывод защищённого атрибута и запуск метода drive() объекта my_car.

## Лабораторная работа №5
### Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Shape: #Создаётся общий (абстрактный) класс для всех фигур
    def area(self): #Создаётся функция площади для фигуры
        pass #пропуск блока

class Rectangle(Shape): #Создание класса прямоугольника, наследуемого от класса Shape
    def __init__(self,width,height): #Конструктор класса Rectangle
        self.width = width #Присвоение параметра width атрибуту self.width объекта
        self.height = height #Присвоение параметра height атрибуту self.height объекта

    def area(self): #Переопределение функции подсёта площади родительского класса для класса прямоугольника
        return self.width*self.height # Возвращение результата подсчёта площади прямоугольника функцией

class Circle(Shape): #Создание класса круга, наследуемого от класса Shape
    def __init__(self,radius): #Конструктор класса Circle
        self.radius = radius #Присвоение параметра radius атрибуту self.radius объекта

    def area(self): #Переопределение функции подсёта площади родительского класса для класса круга
        return 3.14*self.radius*self.radius # Возвращение результата подсчёта площади круга функцией

Figures = [Rectangle(4,5),Circle(3)] #Создание списка (массива) фигур
for figure in Figures: #Вызов функции подсчёта площади для каждой фигуры из списка фигур
    print(figure.area())
```

### Результат
![Лаб5](https://github.com/1eaf1/SE/blob/Тема_8/pic/Лаб5.png)

## Выводы
В данном коде осуществляется создание общего класса Shape для фигур и двух конкретных классов Circle и Rectangle для двух конкретных фигур - круга и прямоугольника. Оба класса наследуют класс Shape. Внутри этих классов функции имеют одинаковые названия, однако объекты вызывающие эти функции ведут себя по-разному, поскольку в каждом из двух классов - Rectangle и Circle эти функции переопределены от функции Shape. Таким образом, это признак проявления полиморфизма.

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Bird:
    def __init__(self):
        pass

bird1 = Bird()
print(bird1)
```

### Результат
![Сам1](https://github.com/1eaf1/SE/blob/Тема_8/pic/Сам2.png)

## Выводы
В данном коде создаётся пустой класс Bird и объект этого класса bird1. В консоль выводится информация о существовании данного объекта.
  
## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Bird:
    def __init__(self,name,type):
        self.name = name
        self.type = type
    def Sound(self):
        print(f"{self.type} {self.name} is making sound!")

bird1 = Bird("Kesha","Parrot")
bird1.Sound()
```

### Результат
![Сам2](https://github.com/1eaf1/SE/blob/Тема_8/pic/Сам1.png)

## Выводы
В данном коде создаётся класс Bird, который принимает в качестве атрибутов два параметра - name и type, в данном классе имеется функция Sound, которая выводит в консоль, что птица определённого вида с определённым именем издаёт звук. За пределами класса осуществляется создание объекта bird1 этого класса и вызов метода Sound().
  
## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Bird:
    def __init__(self,name,type):
        self.name = name
        self.type = type
    def Sound(self):
        print(f"{self.type} {self.name} is making sound!")

class Duck(Bird):
    def __init__(self):
        self.type="Duck"

    def Sound(self):
        print(f"{self.type} is Quack! Quack!")

    def Fly(self):
        print(f"{self.type} is flying!")

duck = Duck()
duck.Sound()
duck.Fly()
```

### Результат
![Сам3](https://github.com/1eaf1/SE/blob/Тема_8/pic/Сам3.png)

## Выводы
В данном коде осуществляется наследование новым классом Duck методов и атрибутов из класса Bird, однако в классе Duck осуществляется переопределение функции инициализации init() и функции издания звука - Sound(), а также добавляется новая функция полёта птицы - Fly().

  
## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать сранее созданным классом. Она должна отличаться, от того, чтоуказана в теоретическом материале (методичке) и лабораторныхзаданиях. Результатом выполнения задания будет листинг кода иполучившийся вывод консоли.

```python
class Bird:
    def __init__(self,name,type):
        self.name = name
        self.type = type
    def Sound(self):
        print(f"{self.type} {self.name} is making sound!")

class Duck(Bird):
    def __init__(self):
        self.__type="Duck"

    def Sound(self):
        print(f"{self.__type} is Quack! Quack!")

    def Fly(self):
        print(f"{self.__type} is flying!")

duck = Duck()
duck.__type = "Parrot"
duck.Sound()
duck.Fly()
```

### Результат
![Сам4](https://github.com/1eaf1/SE/blob/Тема_8/pic/Сам4.png)

## Вывод
В данном коде атрибут type класса Duck делается приватным в целях недопущения смены кем-либо вида птицы. При попытке присвоить объекту duck новый вид "Parrot" - ничего не происходит и всё так же в консоли при вызове методов выводится вид присущий данному классу - вид "Duck".

  
## Самостоятельная работа №5
- Текст задания
- Оформленный код
- Скрины консоли
- Развернутый вывод
  
## Общие выводы по теме
- Развернутый вывод
